<!DOCTYPE html>
    <html>
    <head>
        <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
        <style>
/*--------------------------------------------------------------------------------------------- * Copyright (c) Microsoft Corporation. All rights reserved. * Licensed under the MIT License. See License.txt in the project root for license information. *--------------------------------------------------------------------------------------------*/ body { font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback"; font-size: 14px; padding: 0 12px; line-height: 22px; word-wrap: break-word; } body.scrollBeyondLastLine { margin-bottom: calc(100vh - 22px); } body.showEditorSelection .code-line { position: relative; } body.showEditorSelection .code-active-line:before, body.showEditorSelection .code-line:hover:before { content: ""; display: block; position: absolute; top: 0; left: -12px; height: 100%; } body.showEditorSelection li.code-active-line:before, body.showEditorSelection li.code-line:hover:before { left: -30px; } .vscode-light.showEditorSelection .code-active-line:before { border-left: 3px solid rgba(0, 0, 0, 0.15); } .vscode-light.showEditorSelection .code-line:hover:before { border-left: 3px solid rgba(0, 0, 0, 0.40); } .vscode-dark.showEditorSelection .code-active-line:before { border-left: 3px solid rgba(255, 255, 255, 0.4); } .vscode-dark.showEditorSelection .code-line:hover:before { border-left: 3px solid rgba(255, 255, 255, 0.60); } .vscode-high-contrast.showEditorSelection .code-active-line:before { border-left: 3px solid rgba(255, 160, 0, 0.7); } .vscode-high-contrast.showEditorSelection .code-line:hover:before { border-left: 3px solid rgba(255, 160, 0, 1); } img { max-width: 100%; max-height: 100%; } a { color: #4080D0; text-decoration: none; } a:focus, input:focus, select:focus, textarea:focus { outline: 1px solid -webkit-focus-ring-color; outline-offset: -1px; } hr { border: 0; height: 2px; border-bottom: 2px solid; } h1 { padding-bottom: 0.3em; line-height: 1.2; border-bottom-width: 1px; border-bottom-style: solid; } h1, h2, h3 { font-weight: normal; } h1 code, h2 code, h3 code, h4 code, h5 code, h6 code { font-size: inherit; line-height: auto; } a:hover { color: #4080D0; text-decoration: underline; } table { border-collapse: collapse; } table > thead > tr > th { text-align: left; border-bottom: 1px solid; } table > thead > tr > th, table > thead > tr > td, table > tbody > tr > th, table > tbody > tr > td { padding: 5px 10px; } table > tbody > tr + tr > td { border-top: 1px solid; } blockquote { margin: 0 7px 0 5px; padding: 0 16px 0 10px; border-left: 5px solid; } code { font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback"; font-size: 14px; line-height: 19px; } body.wordWrap pre { white-space: pre-wrap; } .mac code { font-size: 12px; line-height: 18px; } code > div { padding: 16px; border-radius: 3px; overflow: auto; } /** Theming */ .vscode-light { color: rgb(30, 30, 30); } .vscode-dark { color: #DDD; } .vscode-high-contrast { color: white; } .vscode-light code { color: #A31515; } .vscode-dark code { color: #D7BA7D; } .vscode-light code > div { background-color: rgba(220, 220, 220, 0.4); } .vscode-dark code > div { background-color: rgba(10, 10, 10, 0.4); } .vscode-high-contrast code > div { background-color: rgb(0, 0, 0); } .vscode-high-contrast h1 { border-color: rgb(0, 0, 0); } .vscode-light table > thead > tr > th { border-color: rgba(0, 0, 0, 0.69); } .vscode-dark table > thead > tr > th { border-color: rgba(255, 255, 255, 0.69); } .vscode-light h1, .vscode-light hr, .vscode-light table > tbody > tr + tr > td { border-color: rgba(0, 0, 0, 0.18); } .vscode-dark h1, .vscode-dark hr, .vscode-dark table > tbody > tr + tr > td { border-color: rgba(255, 255, 255, 0.18); } .vscode-light blockquote, .vscode-dark blockquote { background: rgba(127, 127, 127, 0.1); border-color: rgba(0, 122, 204, 0.5); } .vscode-high-contrast blockquote { background: transparent; border-color: #fff; }
</style>
<style>
/* Tomorrow Theme */ /* http://jmblog.github.com/color-themes-for-google-code-highlightjs */ /* Original theme - https://github.com/chriskempson/tomorrow-theme */ /* Tomorrow Comment */ .hljs-comment, .hljs-quote { color: #8e908c; } /* Tomorrow Red */ .hljs-variable, .hljs-template-variable, .hljs-tag, .hljs-name, .hljs-selector-id, .hljs-selector-class, .hljs-regexp, .hljs-deletion { color: #c82829; } /* Tomorrow Orange */ .hljs-number, .hljs-built_in, .hljs-builtin-name, .hljs-literal, .hljs-type, .hljs-params, .hljs-meta, .hljs-link { color: #f5871f; } /* Tomorrow Yellow */ .hljs-attribute { color: #eab700; } /* Tomorrow Green */ .hljs-string, .hljs-symbol, .hljs-bullet, .hljs-addition { color: #718c00; } /* Tomorrow Blue */ .hljs-title, .hljs-section { color: #4271ae; } /* Tomorrow Purple */ .hljs-keyword, .hljs-selector-tag { color: #8959a8; } .hljs { display: block; overflow-x: auto; color: #4d4d4c; padding: 0.5em; } .hljs-emphasis { font-style: italic; } .hljs-strong { font-weight: bold; }
</style>
<style>
ul.contains-task-list { padding-left: 0; } ul ul.contains-task-list { padding-left: 40px; } .task-list-item { list-style-type: none; } .task-list-item-checkbox { vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'HelveticaNeue-Light', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
    </head>
    <body>
        <h1 id="creating-a-custom-schematic">Creating a custom Schematic</h1>
<p>Since some versions, the Angular CLI uses a library called <a href="https://www.npmjs.com/package/@angular-devkit/schematics">Schematics</a> to scaffold building blocks like components or services. One of the best things about this is that Schematics allows to create own code generators too. Using this extension mechanism, we can <a href="https://blog.angularindepth.com/creating-your-own-application-template-for-angular-cli-95e22319cc24">modify the way the CLI generates code</a>. But we can also provide custom collections with code generators and publish them as npm packages. A good example for this is <a href="https://nrwl.io/nx">Nrwl's Nx</a> which allows to generate boilerplate code for <a href="https://github.com/ngrx">Ngrx</a> or upgrade an existing application from AngularJS 1.x to Angular.</p>
<p>These code generators are called Schematics and can not only create new files but also modify existing ones. For instance, the CLI uses the latter to register generated components with existing modules.</p>
<p>In this chapter, I'm showing how to create a collection with a custom Schematic from scratch and how to use it with an Angular project. The <a href="https://github.com/manfredsteyer/schematics-intro">sources</a> can be found <a href="https://github.com/manfredsteyer/schematics-intro">here</a>.</p>
<p>In addition to this, you'll find a nice <a href="https://www.youtube.com/watch?v=ZKyz0lb0GjA">video with Mike Brocchi from the CLI-Team explaining the basics and ideas behind Schematics here</a>.</p>
<h2 id="example">Example</h2>
<p>To demonstrate how to write a simple Schematic from scratch, I will build a code generator for a Bootstrap based side menu. With an respective template like the free ones at <a href="https://www.creative-tim.com/">Creative Tim</a> the result could look like this:</p>
<p><img src="file:///c%3A/Users/Manfred/Documents/b%C3%BCcher/Schematics/manuscript/images/solution.png" alt="Solution"></p>
<p>Before creating a generator it is a good idea to have an existing solution that contains the code you want to generate in all variations.</p>
<p>In our case, the component is quite simple:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component, OnInit } from <span class="hljs-string">'@angular/core'</span>;

@Component({
    selector: <span class="hljs-string">'menu'</span>,
    templateUrl: <span class="hljs-string">'menu.component.html'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MenuComponent {
}
</div></code></pre>
<p>In addition to that, the template for this component is just a bunch of html tags with the right Bootstrap based classes -- something I cannot learn by heart which is the reason a generator seems to be a good idea:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sidebar-wrapper"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"logo"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"simple-text"</span>&gt;</span>
            AppTitle
        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav"</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ti-home"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- add here some other items as shown before --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>In addition to the code shown before, I want to also have the possibility to create a more dynamic version of this side menu. This version uses an interface <code>MenuItem</code> to represent the items to display:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> MenuItem {
    title: <span class="hljs-built_in">string</span>;
    iconClass: <span class="hljs-built_in">string</span>;
}
</div></code></pre>
<p>A <code>MenuService</code> is providing instances of <code>MenuItem</code>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { MenuItem } from <span class="hljs-string">'./menu-item'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MenuService {

    <span class="hljs-keyword">public</span> items: MenuItem[] = [
        { title: <span class="hljs-string">'Home'</span>, iconClass: <span class="hljs-string">'ti-home'</span> },
        { title: <span class="hljs-string">'Other Menu Item'</span>, iconClass: <span class="hljs-string">'ti-arrow-top-right'</span> },
        { title: <span class="hljs-string">'Further Menu Item'</span>, iconClass: <span class="hljs-string">'ti-shopping-cart'</span>},
        { title: <span class="hljs-string">'Yet another one'</span>, iconClass: <span class="hljs-string">'ti-close'</span>}
    ];

}
</div></code></pre>
<p>The component gets an instance of the service by the means of dependency injection:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component, OnInit } from <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { menuItem } from <span class="hljs-string">'./menu-item'</span>;
<span class="hljs-keyword">import</span> { menuService } from <span class="hljs-string">'./menu.service'</span>;

@Component({
    selector: <span class="hljs-string">'menu'</span>,
    templateUrl: <span class="hljs-string">'./menu.component.html'</span>,
    providers:[MenuService]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MenuComponent {

    items: MenuItem[];

    <span class="hljs-keyword">constructor</span>(service: MenuService) {
        <span class="hljs-keyword">this</span>.items = service.items;
    }
}
</div></code></pre>
<p>After fetching the <code>MenuItems</code> from the service the component iterates over them using <code>*ngFor</code> and creates the needed markup:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sidebar-wrapper"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"logo"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"simple-text"</span>&gt;</span>
            AppTitle
        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let item of items"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"{{item.iconClass}}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{item.title}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Even though this example is quite easy it provides enough stuff to demonstrate the basics of Schematics.</p>
<h2 id="scaffolding-a-collection-for-schematics-with-schematics">Scaffolding a Collection for Schematics ... with Schematics</h2>
<p>To provide a project structure for an npm package with a Schematics Collection, we can leverage Schematics itself. The reason is that the product team provides a &quot;meta schematic&quot; for this. To use it, download the <code>schematics-cli</code>:</p>
<pre><code>npm i -g @angular-devkit/schematics-cli
</code></pre>
<p>In order to get our collection scaffolded we just need to type in the following command:</p>
<pre><code>schematics schematic --name nav
</code></pre>
<p>After executing this command we get an npm package with a collection that holds three demo schematics:</p>
<p>{width=25%}
<img src="file:///c%3A/Users/Manfred/Documents/b%C3%BCcher/Schematics/manuscript/images/package-structure.png" alt="npm package with collection"></p>
<p>The file <code>collection.json</code> contains metadata about the collection and points to the schematics in the three sub folders. Each schematic has meta data of its own describing the command line arguments it supports as well as generator code. Usually, they also contain template files with placeholders used for generating code. But more about this in the following sections.</p>
<p>Before we can start, we need to <code>npm install</code> the dependencies the generated <code>package.json</code> points to. In addition to that, it is a good idea to rename its <code>dependencies</code> section to <code>devDependencies</code> because we don't want to install them when we load the npm package into a project:</p>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"nav"</span>,
  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"0.0.0"</span>,
  <span class="hljs-attr">"description"</span>: <span class="hljs-string">"A schematics"</span>,
  <span class="hljs-attr">"scripts"</span>: {
    <span class="hljs-attr">"build"</span>: <span class="hljs-string">"tsc -p tsconfig.json"</span>,
    <span class="hljs-attr">"test"</span>: <span class="hljs-string">"npm run build &amp;&amp; jasmine **/*_spec.js"</span>
  },
  <span class="hljs-attr">"keywords"</span>: [
    <span class="hljs-string">"schematics"</span>
  ],
  <span class="hljs-attr">"author"</span>: <span class="hljs-string">""</span>,
  <span class="hljs-attr">"license"</span>: <span class="hljs-string">"MIT"</span>,
  <span class="hljs-attr">"schematics"</span>: <span class="hljs-string">"./src/collection.json"</span>,
  <span class="hljs-attr">"devDependencies"</span>: {
    <span class="hljs-attr">"@angular-devkit/core"</span>: <span class="hljs-string">"^0.0.15"</span>,
    <span class="hljs-attr">"@angular-devkit/schematics"</span>: <span class="hljs-string">"^0.0.25"</span>,
    <span class="hljs-attr">"@types/jasmine"</span>: <span class="hljs-string">"^2.6.0"</span>,
    <span class="hljs-attr">"@types/node"</span>: <span class="hljs-string">"^8.0.31"</span>,
    <span class="hljs-attr">"jasmine"</span>: <span class="hljs-string">"^2.8.0"</span>,
    <span class="hljs-attr">"typescript"</span>: <span class="hljs-string">"^2.5.2"</span>
  }
}
</div></code></pre>
<p>As you saw in the last listing, the <code>packages.json</code> file contains a <code>schematics</code> field which is pointing to the <code>collection.json</code> file to inform about the metadata.</p>
<p>As an alternative, you can also use the blank schematic to generate a new schematic project:</p>
<pre><code>schematic blank --name mySchematic
</code></pre>
<p>It does not scaffold demo schematics but only one blank schematic and it npm installs the dependencies automatically.</p>
<h2 id="adding-a-custom-schematic">Adding a custom Schematic</h2>
<p>The three generated schematics contain comments that describe quite well how Schematics works. It is a good idea to have a look at them. For this tutorial, I've deleted them to concentrate on my own schematic. For this, I'm using the following structure:</p>
<p>{width=25%}
<img src="file:///c%3A/Users/Manfred/Documents/b%C3%BCcher/Schematics/manuscript/images/own-structure.png" alt="Structure for custom Schematics"></p>
<p>The new <code>menu</code> folder contains the custom schematic. Its command line arguments are described by the <code>schema.json</code> file using a json schema. The described data structure can also be found as an interface within the file <code>schema.ts</code>. Normally it would be a good idea to generate this interface out of the schema, but for this simple case I've just handwritten it.</p>
<p>The <code>index.ts</code> contains the so called factory for the schematic. This is a function that generates a rule (containing other rules) which describes how the code can be scaffolded. The templates used for this are located in the <code>files</code> folder. We will have a look at them later.</p>
<p>First of all, let's update the <code>collection.json</code> to make it point to our menu schematic:</p>
<pre class="hljs"><code><div>{
    <span class="hljs-attr">"schematics"</span>: {
      <span class="hljs-attr">"menu"</span>: {
        <span class="hljs-attr">"aliases"</span>: [ <span class="hljs-string">"mnu"</span> ],
        <span class="hljs-attr">"factory"</span>: <span class="hljs-string">"./menu"</span>,
        <span class="hljs-attr">"description"</span>: <span class="hljs-string">"Generates a menu component"</span>,
        <span class="hljs-attr">"schema"</span>: <span class="hljs-string">"./menu/schema.json"</span>
      }
    }
}
</div></code></pre>
<p>Here we have a <code>menu</code> property for the menu schematic. This is also the name we reference when calling it. The array <code>aliases</code> contains other possible names to use and <code>factory</code> points to the file with the schematic's factory. Here, it points to <code>./menu</code> which is just a folder. That's why the factory is looked up in the <code>./menu/index.js</code> file.</p>
<p>In addition to that, the <code>collection.json</code> also points to the schema with the command line arguments. This file describes a property for each possible argument:</p>
<pre class="hljs"><code><div>{
    <span class="hljs-attr">"$schema"</span>: <span class="hljs-string">"http://json-schema.org/schema"</span>,
    <span class="hljs-attr">"id"</span>: <span class="hljs-string">"SchemanticsForMenu"</span>,
    <span class="hljs-attr">"title"</span>: <span class="hljs-string">"Menu Schema"</span>,
    <span class="hljs-attr">"type"</span>: <span class="hljs-string">"object"</span>,
    <span class="hljs-attr">"properties"</span>: {
      <span class="hljs-attr">"name"</span>: {
        <span class="hljs-attr">"type"</span>: <span class="hljs-string">"string"</span>,
        <span class="hljs-attr">"default"</span>: <span class="hljs-string">"name"</span>
      },
      <span class="hljs-attr">"path"</span>: {
        <span class="hljs-attr">"type"</span>: <span class="hljs-string">"string"</span>,
        <span class="hljs-attr">"default"</span>: <span class="hljs-string">"app"</span>
      },
      <span class="hljs-attr">"appRoot"</span>: {
        <span class="hljs-attr">"type"</span>: <span class="hljs-string">"string"</span>
      },
      <span class="hljs-attr">"sourceDir"</span>: {
        <span class="hljs-attr">"type"</span>: <span class="hljs-string">"string"</span>,
        <span class="hljs-attr">"default"</span>: <span class="hljs-string">"src"</span>
      },
      <span class="hljs-attr">"menuService"</span>: {
        <span class="hljs-attr">"type"</span>: <span class="hljs-string">"boolean"</span>,
        <span class="hljs-attr">"default"</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">"description"</span>: <span class="hljs-string">"Indicates whether a menu service should be generated."</span>,
        <span class="hljs-attr">"alias"</span>: <span class="hljs-string">"ms"</span>
      }
    }
  }
</div></code></pre>
<p>There are arguments to hold the <code>name</code> of the menu component, its <code>path</code> as well as the path of the app (<code>appRoot</code>) and the <code>src</code> folder (<code>sourceDir</code>). These parameters are usually used by all the schematics the CLI provides. In addition to that, I've defined a <code>menuService</code> property to indicate whether the above mentioned <code>service</code> class should be generated too.</p>
<p>The interface for the schema within <code>schema.ts</code> is called <code>MenuOptions</code>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> MenuOptions {
    name: <span class="hljs-built_in">string</span>;
    appRoot: <span class="hljs-built_in">string</span>;
    path: <span class="hljs-built_in">string</span>;
    sourceDir: <span class="hljs-built_in">string</span>;
    menuService: <span class="hljs-built_in">boolean</span>;
}
</div></code></pre>
<h2 id="schematic-factory">Schematic Factory</h2>
<p>To tell Schematics how to generate the requested code files, we need to provide a factory. This function describes the necessary steps with a rule which normally makes use of further rules:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { MenuOptions } from <span class="hljs-string">'./schema'</span>;
<span class="hljs-keyword">import</span> { Rule, [...] } from <span class="hljs-string">'@angular-devkit/schematics'</span>;
[...]
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">options: MenuOptions</span>): <span class="hljs-title">Rule</span> </span>{
    [...]
}
</div></code></pre>
<p>For this factory, I've defined two helper constructs at the top of the file:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { dasherize, classify } from <span class="hljs-string">'@angular-devkit/core'</span>;
<span class="hljs-keyword">import</span> { MenuOptions } from <span class="hljs-string">'./schema'</span>;
<span class="hljs-keyword">import</span> { filter, Rule, [...] } from <span class="hljs-string">'@angular-devkit/schematics'</span>;

[...]

<span class="hljs-keyword">const</span> stringUtils = { dasherize, classify };

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filterTemplates</span>(<span class="hljs-params">options: MenuOptions</span>): <span class="hljs-title">Rule</span> </span>{
  <span class="hljs-keyword">if</span> (!options.menuService) {
    <span class="hljs-keyword">return</span> filter(path =&gt; !path.match(<span class="hljs-regexp">/\.service\.ts$/</span>) 
                            &amp;&amp; !path.match(<span class="hljs-regexp">/-item\.ts$/</span>) 
                            &amp;&amp; !path.match(<span class="hljs-regexp">/\.bak$/</span>));
  }
  <span class="hljs-keyword">return</span> filter(path =&gt; !path.match(<span class="hljs-regexp">/\.bak$/</span>));
}

[...]
</div></code></pre>
<p>The first one is the <code>stringUtils</code> object which just groups some functions we will need later within the templates: the <code>dasherize</code> function transforms a name into its kebab case equivalent which can be used as a file name (e. g. <code>SideMenu</code> to <code>side-menu</code>) and <code>classify</code> transforms into Pascal case for class names (e. g. <code>side-menu</code> to <code>SideMenu</code>).</p>
<p>The <code>filterTemplates</code> function creates a Rule that filters the templates within the <code>files</code> folder. For this, it delegates to the existing <code>filter</code> rule. Depending on whether the user requested a menu service, more or less template files are used. To make testing and debugging easier, I'm excluding <code>.bak</code> in each case.</p>
<p>Now let's have a look at the factory function:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { chain, mergeWith } from <span class="hljs-string">'@angular-devkit/schematics'</span>;
<span class="hljs-keyword">import</span> { dasherize, classify } from <span class="hljs-string">'@angular-devkit/core'</span>;
<span class="hljs-keyword">import</span> { MenuOptions } from <span class="hljs-string">'./schema'</span>;
<span class="hljs-keyword">import</span> { apply, filter, move, Rule, template, url, branchAndMerge } 
    from <span class="hljs-string">'@angular-devkit/schematics'</span>;
<span class="hljs-keyword">import</span> { normalize } from <span class="hljs-string">'@angular-devkit/core'</span>;

[...]

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">options: MenuOptions</span>): <span class="hljs-title">Rule</span> </span>{

    options.path = options.path ? normalize(options.path) : options.path;
    
    <span class="hljs-keyword">const</span> templateSource = apply(url(<span class="hljs-string">'./files'</span>), [
        filterTemplates(options),
        template({
          ...stringUtils,
          ...options
        }),
        move(options.sourceDir)
      ]);
      
      <span class="hljs-keyword">return</span> chain([
          mergeWith(templateSource)
      ]);

}
</div></code></pre>
<p>At the beginning, the factory normalizes the path the caller passed in. This means that it deals with the conventions of different operating systems, e. g. using different path separators (e.g. <code>/</code> vs. <code>\</code>).</p>
<p>Then, it uses <code>apply</code> to apply all templates within the <code>files</code> folder to the passed rules. After filtering the available templates they are executed with the rule returned by <code>template</code>. The passed properties are used within the templates. This creates a virtual folder structure with generated files that is moved to the <code>sourceDir</code>.</p>
<p>The resulting <code>templateSource</code> is a <code>Source</code> instance. Its responsibility lies in creating a <code>Tree</code> object that represents a file tree which can be either virtual or physical. Schematics uses virtual file trees as a staging area. Only when everything worked, it is merged with the physical file tree on your disk. You can also think about this as committing a transaction.</p>
<p>At the end, the factory returns a rule created with the <code>chain</code> function (which is a rule too). It creates a new rule by chaining the passed ones. In this example we are just using the rule <code>mergeWith</code> but the enclosing <code>chain</code> makes it extendable.</p>
<p>As the name implies, <code>mergeWith</code> merges the <code>Tree</code> represented by <code>templateSource</code> with the tree which represents the current Angular project.</p>
<h2 id="templates">Templates</h2>
<p>Now it's time to look at our templates within the <code>files</code> folder:</p>
<p>{width=50%}
<img src="file:///c%3A/Users/Manfred/Documents/b%C3%BCcher/Schematics/manuscript/images/templates.png" alt="Folder with Templates"></p>
<p>The nice thing about this is that the file names are templates too. For instance <code>__x__</code> would be replaced with the contents of the variable <code>x</code> which is passed to the <code>template</code> rule. You can even call functions to transform these variables. In our case, we are using <code>__name@dasherize__</code>, which passes the variable <code>name</code> to the function <code>dasherize</code>, which in turn is passed to <code>template</code> too.</p>
<p>The easiest one is the template for the item class which represents a menu item:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> &lt;%= classify(name) %&gt;Item {
    title: <span class="hljs-built_in">string</span>;
    iconClass: <span class="hljs-built_in">string</span>;
}
</div></code></pre>
<p>Like in other known template languages (e. g. PHP), we can execute code for the generation within the delimiters <code>&lt;%</code> and <code>%&gt;</code>. Here, we are using the short form <code>&lt;%=value%&gt;</code> to write a value to the generated file. This value is just the name the caller passed, transformed with <code>classify</code> to be used as a class name.</p>
<p>The template for the menu service is build in a similar way:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { &lt;%= classify(name) %&gt;Item } from <span class="hljs-string">'./&lt;%=dasherize(name)%&gt;-item'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> &lt;%= classify(name) %&gt;Service {

    <span class="hljs-keyword">public</span> items: &lt;%= classify(name) %&gt;Item[] = [
        { title: <span class="hljs-string">'Home'</span>, iconClass: <span class="hljs-string">'ti-home'</span> },
        { title: <span class="hljs-string">'Other Menu Item'</span>, iconClass: <span class="hljs-string">'ti-arrow-top-right'</span> },
        { title: <span class="hljs-string">'Further Menu Item'</span>, iconClass: <span class="hljs-string">'ti-shopping-cart'</span>},
        { title: <span class="hljs-string">'Yet another one'</span>, iconClass: <span class="hljs-string">'ti-close'</span>}
    ];
}
</div></code></pre>
<p>In addition to that, the component template contains some <code>if</code> statements that check whether a menu service should be used:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component, OnInit } from <span class="hljs-string">'@angular/core'</span>;
&lt;% <span class="hljs-keyword">if</span> (menuService) { %&gt;
<span class="hljs-keyword">import</span> { &lt;%= classify(name) %&gt;Item } from <span class="hljs-string">'./&lt;%=dasherize(name)%&gt;-item'</span>;
<span class="hljs-keyword">import</span> { &lt;%= classify(name) %&gt;Service } from <span class="hljs-string">'./&lt;%=dasherize(name)%&gt;.service'</span>;
&lt;% } %&gt;

@Component({
    selector: <span class="hljs-string">'&lt;%=dasherize(name)%&gt;'</span>,
    templateUrl: <span class="hljs-string">'&lt;%=dasherize(name)%&gt;.component.html'</span>,
    &lt;% <span class="hljs-keyword">if</span> (menuService) { %&gt;
        providers: [&lt;%= classify(name) %&gt;Service]
    &lt;% } %&gt;
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> &lt;%= classify(name) %&gt;Component {

&lt;% <span class="hljs-keyword">if</span> (menuService) { %&gt;
    items: &lt;%= classify(name) %&gt;Item[];

    <span class="hljs-keyword">constructor</span>(service: &lt;%= classify(name) %&gt;Service) {
        <span class="hljs-keyword">this</span>.items = service.items;
    }
&lt;% } %&gt;

}
</div></code></pre>
<p>The same is the case for the component's template. When the caller requested a menu service, it's using it; otherwise it just gets hardcoded sample items:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sidebar-wrapper"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"logo"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"simple-text"</span>&gt;</span>
            AppTitle
        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav"</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">%</span> <span class="hljs-attr">if</span> (<span class="hljs-attr">menuService</span>) { %&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let item of items"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"{{item.iconClass}}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{item.title}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">%</span> } <span class="hljs-attr">else</span> { %&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ti-home"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ti-arrow-top-right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Other Menu Item<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>

		<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ti-shopping-cart"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Further Menu Item<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
			<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>

		<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ti-close"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>
				<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Yet another one<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
			<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">%</span> } %&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<h2 id="building-and-testing-with-a-sample-application">Building and Testing with a Sample Application</h2>
<p>To build the npm package, we just need to call <code>npm run build</code> which is just triggering the TypeScript compiler.</p>
<p>For testing it, we need a sample application that can be created with the CLI. Please make sure to use Angular CLI version 1.5 RC.4 or higher.</p>
<p>For me, the easiest way to test the collection was to copy the whole package into the sample application's <code>node_module</code> folder so that everything ended up within <code>node_modules/nav</code>. Please make sure to exclude the collection's <code>node_modules</code> folder, so that there is no folder <code>node_modules/nav/node_modules</code>.</p>
<p>Instead of this, pointing to a relative folder with the collection should work too. In my experiments that I did with a release candidate, this wasn't the case (at least not in any case).</p>
<p>After this, we can use the CLI to scaffold our side menu:</p>
<pre><code>ng g menu side-menu --menuService --collection nav
</code></pre>
<p>Here, <code>menu</code> is the name of the schematic, <code>side-menu</code> is the file name we are passing and <code>nav</code> - the name of the npm package.</p>
<p><img src="file:///c%3A/Users/Manfred/Documents/b%C3%BCcher/Schematics/manuscript/images/cmd-use-schemantic.png" alt="Using the Schematic"></p>
<p>After this, we need to register the generated component with the <code>AppModule</code>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { SideMenuComponent } from <span class="hljs-string">'./side-menu/side-menu.component'</span>;
<span class="hljs-keyword">import</span> { BrowserModule } from <span class="hljs-string">'@angular/platform-browser'</span>;
<span class="hljs-keyword">import</span> { NgModule } from <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-keyword">import</span> { AppComponent } from <span class="hljs-string">'./app.component'</span>;

@NgModule({
  declarations: [
    AppComponent,
    SideMenuComponent
  ],
  imports: [
    BrowserModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppModule { }
</div></code></pre>
<p>In the next chapters, I will show how to even automate this task with Schematics.</p>
<p>After this, we can call the component in our <code>AppModule</code>. The following sample also contains some boilerplate for the Bootstrap Theme used in the initial screenshot.</p>
<pre><code><div class="wrapper">
  <div class="sidebar" data-background-color="white" data-active-color="danger">

      <side-menu></side-menu>
  
  </div>
  <div class="main-panel">
      <div class="content">
        <div class="card">
          <div class="header">
            <h1 class="title">Hello World</h1>
          </div>
          <div class="content">
            <div style="padding:7px">
             Lorem ipsum ...
            </div>
          </div>
        </div>
      </div>
  </div>
</div>
</code></pre>
<p>To get Bootstrap and the Bootstrap Theme, you can download the free version of the <a href="https://www.creative-tim.com/">paper theme</a> and copy it to your <code>assets</code> folder. Also reference the necessary files within the file <code>.angular-cli.json</code> to make sure they are copied to the output folder:</p>
<pre><code>[...]
"styles": [
  "styles.css",
  "assets/css/bootstrap.min.css",
  "assets/css/paper-dashboard.css",
  "assets/css/demo.css",
  "assets/css/themify-icons.css"
],
[...]
</code></pre>
<p>After this, we can finally run our application: <code>ng serve</code>.</p>

    </body>
    </html>